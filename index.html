<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>ASCII Двостороння Дорога</title>
<link rel="icon" href="data:image/svg+xml,
<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'>
  <text x='50%' y='55%' font-size='40' text-anchor='middle' fill='white' font-family='monospace'>=[-]=</text>
</svg>">
<style>
body {
  margin:0; height:100vh; background:191919;
  font-family:monospace; white-space:pre; overflow:hidden;
}
.car { position:absolute; font-weight:bold; }
.lane, .divider { position:absolute; width:100%; }
.lane { border-top:1px solid gray; opacity:0.3; }
.divider { border-top:4px double yellow; opacity:0.8; }
</style>
</head>
<body>
<script>
const carSprites = ['=(o)≡','≡[+]≡','(o)=(o)=[:]','=[:]=','<[•)>','=[-]=','[]=o=[]','<(o)>'],
      carColors  = ['red','orange','yellow','lime','cyan','blue','magenta','white'],
      cars = [];

const laneCount = 3,
      safeDistance = 7,
      laneHeight = 30,
      screenWidth = innerWidth,
      cellWidth = 10,
      maxCells = screenWidth / cellWidth;

const addEl = (cls, top) => {
  const el = document.createElement('div');
  el.className = cls;
  el.style.top = top + 'px';
  document.body.appendChild(el);
  return el;
};

const laneTops = Array.from({length: laneCount*2}, (_,i)=>
  i*laneHeight + (i>=laneCount?laneHeight/2:0)
);
laneTops.forEach(t=>addEl('lane',t));
[ laneCount*laneHeight, laneCount*laneHeight + laneHeight/2 ]
  .forEach(t=>addEl('divider',t));
addEl('lane', laneTops.at(-1) + laneHeight);

carSprites.forEach((sprite,i)=>{
  const lane = i % (laneCount*2),
        car  = document.createElement('div');
  car.className = 'car';
  car.innerText = sprite;
  car.style.color = carColors[i % carColors.length];
  car.style.top = laneTops[lane] + (lane===laneCount?12:5) + 'px';
  document.body.appendChild(car);
  
  cars.push({
    element: car,
    x: Math.random() * maxCells,
    speed: (0.5 + Math.random()*2)/16,
    direction: lane < laneCount ? 1 : -1,
    lane
  });
});

const adjustSpeed = car => {
  const slowed = cars.some(other =>
    other !== car && other.lane === car.lane &&
    ((car.direction>0 && other.x>car.x && other.x-car.x<safeDistance) ||
     (car.direction<0 && car.x>other.x && car.x-other.x<safeDistance))
  );
  car.currentSpeed = slowed ? car.speed*0.3 : car.speed;
};

(function animate(){
  cars.forEach(c=>{
    adjustSpeed(c);
    c.x += (c.currentSpeed || c.speed) * c.direction;
    if(c.x > maxCells && c.direction>0) c.x = -c.element.innerText.length;
    if(c.x < -c.element.innerText.length && c.direction<0) c.x = maxCells;
    c.element.style.left = (c.x*cellWidth) + 'px';
  });
  requestAnimationFrame(animate);
})();
</script>
</body>
</html>

