<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>ASCII Двостороння дорога</title>
<style>
body{
  margin:0; height:100vh; background:#191919; font-family:monospace; white-space:pre; overflow:hidden;
}
.car{position:absolute; font-weight:bold;}
.lane, .divider{position:absolute; width:100%;}
.lane{border-top:1px solid gray; opacity:0.3;}
.divider{border-top:4px double yellow; opacity:0.8;}
</style>
</head>
<body>
<script>
const carSprites = ['=(o)≡','≡[+]≡','(o)=(o)=[:]','=[:]=','<[•)>','=[-]=','[]=o=[]','<(o)>'],
      carColors = ['red','orange','yellow','lime','cyan','blue','magenta','white'],
      cars = [];

const laneCount = 3;     // кількість смуг
const safeDistance = 7;  // мінімальна відстань у символах
const laneHeight = 30;
const screenWidth = window.innerWidth;
const cellWidth = 10;

// створення елементів дороги
function createElement(cls, top){
  const el = document.createElement('div');
  el.className = cls;
  el.style.top = top + 'px';
  document.body.appendChild(el);
  return el;
}

// смуги та роздільники
const laneTops = [];
for(let i=0;i<laneCount*2;i++){
  let top = i*laneHeight + (i>=laneCount?laneHeight/2:0);
  laneTops.push(top);
  createElement('lane', top);
}
createElement('divider', laneCount*laneHeight);
createElement('divider', laneCount*laneHeight + laneHeight/2);
createElement('lane', laneTops[laneTops.length-1] + laneHeight);

// створення машини
function createCar(sprite, color, lane){
  const car = document.createElement('div');
  car.className = 'car';
  car.innerText = sprite;
  car.style.color = color;
  car.style.top = laneTops[lane] + 5 + (lane === laneCount?7:0) + 'px';
  document.body.appendChild(car);
  
  cars.push({
    element: car,
    x: Math.random() * (screenWidth / cellWidth),
    speed: (0.5 + Math.random()*2)/16,
    direction: lane < laneCount ? 1 : -1,
    lane: lane
  });
}

// створюємо машини
carSprites.forEach((sprite,i)=>createCar(sprite, carColors[i%carColors.length], i%(laneCount*2)));

// перевірка безпечної дистанції та зменшення швидкості
function adjustSpeed(car){
  let slowed = cars.some(other=>{
    if(other===car || other.lane!==car.lane) return false;
    return (car.direction>0 && other.x>car.x && other.x-car.x<safeDistance) ||
           (car.direction<0 && car.x>other.x && car.x-other.x<safeDistance);
  });
  car.currentSpeed = slowed ? car.speed*0.3 : car.speed;
}

// анімація
(function animate(){
  cars.forEach(c=>{
    adjustSpeed(c);
    c.x += (c.currentSpeed || c.speed) * c.direction;
    const maxCells = screenWidth/cellWidth;
    if(c.x>maxCells && c.direction>0) c.x = -c.element.innerText.length;
    if(c.x<-c.element.innerText.length && c.direction<0) c.x = maxCells;
    c.element.style.left = c.x*cellWidth + 'px';
  });
  requestAnimationFrame(animate);
})();
</script>
</body>

</html>
